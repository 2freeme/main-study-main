# 数据结构

## 位运算

### 位运算符号

| 符号 | 描述       | 运算规则                                                     |
| :--- | ---------- | ------------------------------------------------------------ |
| &    | 与         | 两个位都为1时，结果才为1                                     |
| \|   | 或         | 两个位都为0时，结果才为0                                     |
| ^    | 异或       | 两个位相同为0，相异为1                                       |
| ~    | 取反       | 0变1，1变0                                                   |
| <<   | 左移       | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移       | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |
| >>>  | 无符号右移 | 无符号右移(>>>)只对32位和64位有意义  在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0 |

## 数组

#### 介绍

- **数组是在内存中存储相同数据类型的连续的空间**

- 引用类型

- 数组长度一旦声明,不可改变不可追加。

- ArrayList的底层就是用数组实现的

- 因为数组的在内存空间的连续性，可以可以直接通过索引找到对应的位置，直接读取数据，所以比较快 O(1)

  ![](image\数组.jpg)

#### 二维数组

- 实质就是存储是一维数组。
-  数组类型[][] 数组名 = new 数组类型[一维数组的个数][每一个一维数组中元素的个数];

![](image\二维数组.png)

#### ArrayList

##### 可以伸缩的数组

- 扩容的本质就是复制一个新的数组
- 只有容量不够的时候才会扩容，扩容是原容量的1.5倍



## 链表

#### 介绍

- 引用类型

- 物理存储单元上，非连续、非顺序的存储结构

- 单向链表

  ![](image\单向链表.png)

  - 单向链表在查询的时候需要从头开始查，挨个节点往下找，直到找到合适的，所以复杂度 O（n）
  - 但是单向链表插入的时候，只需要找到插入的点的前一位，然后将其的指向改成插入的地方即可

#### LinkedList



## HashMap

#### 介绍

- 数据结构和算法 组合一个程序
- 1.7之前使用的做法，就是 数组+链表
- 1.8之后就是 数组+链表+红黑树
  - 查询，就是先根据hashCode定位到数组的哪一个节点上，就是数据的那一个的队列上，然后再根据这个hashcode进行对这个的节点上的链表的挨个对比。
  - 引入红黑树，就是为了解决hash冲突引起的链化严重的问题，本身的是o(1),但是后面的化链化严重会成为O(N),所以引入树的特性，严重的影响了查询性能。
  - Node 结构 key字段  value字段  next字段  hash字段   
    - 这个hash值是key的hashcode的二次加工得到的 高16位 和低16位的异或 得到的值 
    - 高低位的异或主要是为了优化寻址算法，因为hashmap的散列表大多数小于16的，所以如果是hash值大约16的话，他的高位都没有用了，所以用高低位的异或作为一个增加散列度
    - 因为hash的寻址算法的缘故：数组的长度必须是2的整数倍  。 寻址算法  hash  &（table.length-1）
    - 最终 hash寻址  hashCode的高低16位 异或  &（table.length-1） 根据这个得到槽位下标
  - 红黑树的原则
    - 树节点都会有颜色
    - 根节点 都是黑色
    - 黑高
    - 不能有2个红色节点相连
    - 新节点的都是红插

#### PUT

- slot = null
- slot ！=null  但未成链
  - 判断是否相等 是则replace  否则hash冲突尾插法加一个链
- slot已经成为链
  - 挨个的进行比较 equals  然后放到最后，再判断是否达到树化阈值，然后进行树化

#### 创建

- 懒加载机制  创建为空 put的时候给的是16
- 负载因子 0.75   达到这个阈值需要扩容
- 链表转化为红黑树，链表的长度为8或者是当前的散列表数组的长度达到64 

#### 扩容

- 写操作
- 记录数据量达到阈值，然后下一个写入就会进行扩容
- table都是左移一位进行扩容，位运算比较高。
- 扩容的都是2的倍数
- 红黑树的也是有个链表的结构的，为了扩容。

##### 迁移

- 挨个桶位的迁移
- 迁移
  - slot=null
  - slot 单个node
    - 无next，直接重新计算迁移即可
  - slot链表
    - 将其拆分成高位链和低位链
    - 然后直接将高位链进行移动即可
    - ![](\image\数组扩容.jpg)
    - HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，这也是为啥数组长度必须是2的幂次原因之一
  - 红黑树
    - 红黑树本身也是维护了一个链表的一个结构的
    - 扩容的时候拆分成 高低位的链表，然后进行迁移。

#### hash的概念

- 就是将任意长度的输入通过hash算法之后映射成固定长度的输出。

#### hash冲突

- 无法避免  槽位的问题，
- 尽量避免 好的hash算法
  - 效率高，长文本高效计算
  - 无法逆推
  - 尽可能的分散

#### hash算法

- 根据hashcode 的高
- cpu是不支持乘法的运算的，所有的运算都是转化成位运算的操作的

#### HashCode

- 通过字符串算出他的acsi码，进行mod，算出哈希表的下标

- Java中的hashCode方法就是根据一定的规则将与对象

- 相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。即在散列集合包括HashSet、HashMap以及HashTable里，对每一个存储的桶元素都有一个唯一的"块编号"，即它在集合里面的存储地址；当你调用contains方法的时候，它会根据hashcode找到块的存储地址从而定位到该桶元素。

- 其实就是指的是java的原生的方法，然后根据属性之类的生成的值

- 范围：hashcode的取值范围在32以上编译器为 -2^31 到 2^31-1，java采用的是2进制补码机制，第一位符号位，最大值为0x7FFFFFFF，即（2147483647）。

- 验证了算法，其实是综合比较了属性，所以hashcode不一样可以断定 不一样的属性 ，hashCode可以加快运算

  ```java
          Entity entity = new Entity();
          Entity entity2 = new Entity();
          System.out.println(entity.hashCode() == entity2.hashCode());  //true
          entity2.setA(1);
          System.out.println(entity.hashCode() == entity2.hashCode());  //false
          Entity entity3 =entity;
          System.out.println(entity.hashCode() ==entity3.hashCode());   //true
  ```

  

