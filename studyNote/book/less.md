---
typora-root-url: image
---

# 欠缺部分

##### ThreadLocal 

##### B+树的树深

##### CAP的理论知识及一些常见的组件

##### 技术选型的对比（例如mq）

##### springCloud的一些知识的储备

##### 高并发场景的解决办法

##### mysql巨大数据量的处理

##### rocketMq的延迟的原理

##### DDD的理解

##### jvm的深入（短时间看不完了）



## 补充

增加性能的最快捷的方式就是解耦，各司其职，分而治之

### 技术选型

### MQ

- **RabbitMQ**

  erlang开发，延迟比较低

  **RocketMQ**

  java开发，面向互联网集群化功能丰富 可以支持几百个topic

  **kafka**

  Scala开发，面向日志功能丰富  几十到几百的时候会性能下降

  **ActiveMQ**

  java开发，简单，稳定 但是并发级别比较低

- 消息的作用：
  - 解耦  减少系统依赖，提高可用性
  - 异步  减少相应时间，提升用户体验
  - 销峰  高流量销峰，提高可用行
  - 缺点：
    - 系统的可用性变低，因为引入了其他的组件
    - 系统的复杂性提高，因为会涉及到，重复消费，幂等之类的
    - 数据的一致性，因为涉及到了异步
  
- mq的死信队列

- mq的顺序消费的机制

  - 即使是Topic的分片，发送的时候，是把他放在特定的broker中的特定queue中的。
  - 之所以需要topic的分片是因为，本身的话做消息的负载均衡
  - 一个queue只会被一个consumer进行消费

- mq的延迟的机制

  - RocketMQ提供了延时消息类型，简单来说就是生产者在发送消息的时候指定一个延时时间，当到达延时时间之后消息才能够被投送到消费者。
  - 

- mq的producer

  - 是以groupname 和  ip地址作为一个唯一标识



### java中的锁

#### CAS 自旋锁

- compare and set  乐观锁的一种，会拿出当前的值，然后进行操作，然后结束的时候将现在的值和以前的拿出来的值进行对比，然后再判断是否成功

  ![](/CAS自旋锁2.jpg)

  - 问题：这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好
  - ![](/CAS自旋锁对于atomic类的优化.jpg)
  - 分段加锁以及自动分段迁移 / 合并加锁。，
  - ![](/分段锁.jpg)

### CAS

#### AbstractQueuedSynchronizer，抽象队列同步器

![](/AQS执行.jpg)

- 本身的ReentrantLock 就是一个非公平的锁，公平的话会影响性能
- 不过要知道 java 并发包里很多锁默认的策略都是非公平的，也就是可能后来的线程先加锁，先来的线程后加锁。

- 而一般情况下，非公平的策略都没什么大问题，但是大家要对这个策略做到心里有数，在开发的时候，需要自己来考虑和权衡是要用公平策略还是非公平策略。

  



### springCloud全家桶

![](/springcloud.jpg)

**Fegin完美的契合了Eureka，自带了 Ribbon和 Hystrix （Hystrix需要手动开启）**

**zuul默认集成了：ribbon和hystrix。**

#### Eureka

- 思想
  - 迪米特原则，一个对象尽可能少的知道另个对象，别和陌生人说话

- 自我保护机制
  - Eureka在CAP理论当中是属于AP ， 也就说当产生网络分区时，Eureka保证系统的可用性，但不保证系统里面数据的一致性
  - 默认情况下，Eureka Server在一定时间内，没有接收到某个微服务心跳，会将某个微服务注销（90S）。但是当网络故障时，微服务与Server之间无法正常通信，上述行为就非常危险，因为微服务正常，不应该注销。
  - Eureka Server通过自我保护模式来解决整个问题，当Server在短时间内丢失过多客户端时，那么Server会进入自我保护模式，会保护注册表中的微服务不被注销掉。当网络故障恢复后，退出自我保护模式。
  - 宁可保留健康的和不健康的，也不盲目注销任何健康的服务。
  - 客户端每分钟续约数量小于客户端总数的85%时会触发保护机制
  - 多级缓存的优点
    - 尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。
    - 并且进一步保证对 Eureka Server 的大量请求，都是快速从纯内存走，性能极高。
    - 为方便大家更好的理解，同样来一张图，大家跟着图再来回顾一下这整个过程：
- Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里
  - ![](/eureka的多级缓存.jpg)

#### Ribbon

- **负载均衡**
  - 负载均衡分为 服务端负载均衡  客户端负载均衡。客户端负载均衡和服务端负载均衡最大的区别在于 ***服务端地址列表的存储位置，以及负载算法在哪里***。
  - 服务端负载均衡：在服务端负载均衡中，客户端节点只知道单一服务代理的地址，服务代理则知道所有服务端的地址。类似于Nginx
  - 客户端负载均衡：，所有的客户端节点都有一份自己要访问的服务端地址列表，这些列表统统都是从服务注册中心获取的；ribbion就是客户端负载均衡
  - Ribbon可以单独使用，作为一个独立的负载均衡组件。只是需要我们手动配置 服务地址列表。
- **配合eureka**
  - Ribbon与Eureka配合使用时，Ribbon可自动从Eureka Server获取服务提供者地址列表（DiscoveryClient），并基于负载均衡算法，请求其中一个服务提供者实例。
  - Ribbon与OpenFeign和RestTmplate进行无缝对接，让二者具有负载均衡的能力。OpenFeign默认集成了ribbon。
  - Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台
- **策略算法**
  - ZoneAvoidanceRule（区域权衡策略）：复合判断Server所在区域的性能和Server的可用性，轮询选择服务器。

  - BestAvailableRule（最低并发策略）：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。逐个找服务，如果断路器打开，则忽略。
  - RoundRobinRule（轮询策略）：以简单轮询选择一个服务器。按顺序循环选择一个server。

  - RandomRule（随机策略）：随机选择一个服务器。

  - AvailabilityFilteringRule（可用过滤策略）：会先过滤掉多次访问故障而处于断路器跳闸状态的服务和过滤并发的连接数量超过阀值得服务，然后对剩余的服务列表安装轮询策略进行访问。

  - WeightedResponseTimeRule（响应时间加权策略）：据平均响应时间计算所有的服务的权重，响应时间越快服务权重越大，容易被选中的概率就越高。刚启动时，如果统计信息不中，则使用RoundRobinRule(轮询)策略，等统计的信息足够了会自动的切换到WeightedResponseTimeRule。响应时间长，权重低，被选择的概率低。反之，同样道理。此策略综合了各种因素（网络，磁盘，IO等），这些因素直接影响响应时间。
  - RetryRule（重试策略）：先按照RoundRobinRule(轮询)的策略获取服务，如果获取的服务失败则在指定的时间会进行重试，进行获取可用的服务。如多次获取某个服务失败，就不会再次获取该服务。主要是在一个时间段内，如果选择一个服务不成功，就继续找可用的服务，直到超时。
- Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
  - 设置 Hystrix 的线程池 ：响应时间、系统高峰 QPS、有多少台机器，来计算出来，线程池的大小以及超时时间！
- Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务
- **其实对于服务，每一个接口都是需要做幂等的，因为其实有fegin和ribbion的重试机制导致的，因为重试的时候是按照原来的参数进行重试的，所以要保证在实现方做一些接口的幂等的校验**
- 微服务为什么不用服务端的负载均衡
  - 坏处：先得找到负载均衡服务器，怎么找，需要ip和端口，和微服务 悖论了（因为首先得用客户端负载均衡，到达服务端负载均衡后，再解析后续地址，为什么不一步到位呢？ 还能减少一个服务。）。就算找到了，然后再增加一层 服务名到ip的解析。如果有服务端负载均衡的话，需要客户端先请求一个服务端负载均衡，然后负载均衡再去找具体ip，如果服务端负载均衡挂了，就瘫痪了。

#### Fegin

- 主程序入口添加 @EnableFeignClients 注解开启对Feign Client扫描加载处理。根据Feign Client的开发规范，定义接口并加@FeignClient注解。
- 当程序启动时，会进行包扫描，扫描所有@FeignClient注解的类，并将这些信息注入Spring IoC容器中。当定义的Feign接口中的方法被调用时，通过JDK的代理方式，来生成具体的RequestTemplate。当生成代理时，Feign会为每个接口方法创建一个RequestTemplate对象，该对象封装了HTTP请求需要的全部信息，如请求参数名、请求方法等信息都在这个过程中确定。
- 然后由RequestTemplate生成Request，然后把这个Request交给client处理，这里指的Client可以是JDK原生的URLConnection、Apache的Http Client，也可以是Okhttp。最后Client被封装到LoadBalanceClient类，这个类结合Ribbon负载均衡发起服务之间的调用。
- Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求

#### 熔断

- ***当我自身 依赖的服务不可用时，服务自身不会被拖垮。防止微服务级联异常***。

  - 是隔离坏的服务，不让坏服务拖垮其他服务（调用坏服务的服务）。

- **舱壁模式**

  - 舱壁模式（Bulkhead）隔离了每个工作负载或服务的关键资源，如连接池、内存和CPU，硬盘。每个工作单元都有独立的 连接池，内存，CPU。

  - 使用舱壁避免了单个服务消耗掉所有资源，从而导致其他服务出现故障的场景。
    这种模式主要是通过防止由一个服务引起的级联故障来增加系统的弹性。

- **雪崩效应**

  - 雪崩：由基础服务故障导致级联故障的现象。描述的是：提供者不可用 导致消费者不可用，并将不可用逐渐放大的过程。像滚雪球一样，不可用的服务越来越多。影响越来越恶劣。

  - 雪崩三个流程：

    - 服务提供者不可用


    - 重试会导致网络流量加大，更影响服务提供者。


    - 导致服务调用者不可用，由于服务调用者 一直等待返回，一直占用系统资源。


    - （不可用的范围 被逐步放大）

  - 服务不可用原因：

    - 服务器宕机


    - 网络故障


    - 宕机


    - 程序异常


    - 负载过大，导致服务提供者响应慢


    - 缓存击穿导致服务超负荷运行

  - 总之 ： 基础服务故障  导致 级联故障   就是  雪崩。

- **容错机制**

  - 为网络请求设置超时。

  - **使用断路器模式**

    - 如果对某个微服务请求有大量超时（说明该服务不可用），再让新的请求访问该服务就没有意义，只会无谓的消耗资源。例如设置了超时时间1s，如果短时间内有大量的请求无法在1s内响应，就没有必要去请求依赖的服务了。

    - 断路器是对容易导致错误的操作的代理。这种代理能统计一段时间内的失败次数，并依据次数决定是正常请求依赖的服务还是直接返回。

    - 断路器可以实现快速失败，如果它在一段时间内检测到许多类似的错误（超时），就会在之后的一段时间，强迫对该服务的调用快速失败，即不再请求所调用的服务。这样对于消费者就无须再浪费CPU去等待长时间的超时。

    - 断路器也可自动诊断依赖的服务是否恢复正常。如果发现依赖的服务已经恢复正常，那么就会恢复请求该服务。通过重置时间来决定断路器的重新闭合。

    - 这样就实现了微服务的“自我修复”：当依赖的服务不可用时，打开断路器，让服务快速失败，从而防止雪崩。当依赖的服务恢复正常时，又恢复请求。

    - ```
      关闭状态：正常情况下，断路器关闭，可以正常请求依赖的服务。
      
      打开状态：当一段时间内，请求失败率达到一定阈值，断路器就会打开。服务请求不会去请求依赖的服务。调用方直接返回。不发生真正的调用。重置时间过后，进入半开模式。
      
      半开状态：断路器打开一段时间后，会自动进入“半开模式”，此时，断路器允许一个服务请求访问依赖的服务。如果此请求成功(或者成功达到一定比例)，则关闭断路器，恢复正常访问。否则，则继续保持打开状态。
      
      断路器的打开，能保证服务调用者在调用异常服务时，快速返回结果，避免大量的同步等待，减少服务调用者的资源消耗。并且断路器能在打开一段时间后继续侦测请求执行结果，判断断路器是否能关闭，恢复服务的正常调用。
      ```

  - **降级**

    - 为了在整体资源不够的时候，适当放弃部分服务，将主要的资源投放到核心服务中，待渡过难关之后，再重启已关闭的服务，保证了系统核心服务的稳定。当服务停掉后，自动进入fallback替换主方法。


    - 用fallback方法代替主方法执行并返回结果，对失败的服务进行降级。当调用服务失败次数在一段时间内超过了断路器的阈值时，断路器将打开，不再进行真正的调用，而是快速失败，直接执行fallback逻辑。服务降级保护了服务调用者的逻辑。

    - ```
      熔断和降级：
      共同点：
      	1、为了防止系统崩溃，保证主要功能的可用性和可靠性。
      	2、用户体验到某些功能不能用。
      不同点：
      	1、熔断由下级故障触发，主动惹祸。
      	2、降级由调用方从负荷角度触发，无辜被抛弃。
      ```

- #### **Hystrix**

  - 是一个容错的组件

  - Hystrix实现了 超时机制和断路器模式。

  - **功能**

    - 为系统提供保护机制。在依赖的服务出现高延迟或失败时，为系统提供保护和控制。
    - 防止雪崩。
    - 包裹请求：使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中运行。
    - 跳闸机制：当某服务失败率达到一定的阈值时，Hystrix可以自动跳闸，停止请求该服务一段时间。
    - 资源隔离：Hystrix为每个请求都的依赖都维护了一个小型线程池，如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。防止级联失败。
    - 快速失败：Fail Fast。同时能快速恢复。侧重点是：（不去真正的请求服务，发生异常再返回），而是直接失败。
    - 监控：Hystrix可以实时监控运行指标和配置的变化，提供近实时的监控、报警、运维控制。
    - 回退机制：fallback，当请求失败、超时、被拒绝，或当断路器被打开时，执行回退逻辑。回退逻辑我们自定义，提供优雅的服务降级。
    - 自我修复：断路器打开一段时间后，会自动进入“半开”状态，可以进行打开，关闭，半开状态的转换。前面有介绍。

  - **使用** 

    - feign自带Hystrix，但是默认没有打开，首先打开Hystrix。(从Spring Cloud Dalston开始，feign的Hystrix 默认关闭，如果要用feign，必须开启)  

    - 可以自定义的异常的处理，也可以强行熔断。代码中控制

    - ```
      feign:
        hystrix:
          enabled: true 
         
      @FeignClient(name = "service-sms",fallback = SmsClientFallback.class)   
      ```

  - **隔离策略**

    - 信号量隔离
      - 其实就是个计数器，使用该方式，HystrixCommand将会在调用线程上执行，通过信号量限制单个服务提供者的并发量，开销相对较小（因为不用那么多线程池），并发请求受到信号量个数的限制。 线程隔离会带来线程开销，有些场景（比如无网络请求场景）可能会因为用开销换隔离得不偿失，为此hystrix提供了信号量隔离，当服务的并发数大于信号量阈值时将进入fallback。
    - 线程池隔离
      - 使用该方式，HystrixCommand将会在单独的线程上执行，并发请求受线程池中线程数量的限制。不同服务通过使用不同线程池，彼此间将不受影响，达到隔离效果。
    - 一般来说，只有当调用负载异常高时（例如每个实例每秒调用数百次）才需要信号量隔离，因为这种场景下使用THREAD开销会比较高。信号量隔离一般仅适用于非网络调用的隔离。 
    - 线程池和信号量都支持熔断和限流。相比线程池，信号量不需要线程切换，因此避免了不必要的开销。但是信号量不支持异步，也不支持超时，也就是说当所请求的服务不可用时，信号量会控制超过限制的请求立即返回，但是已经持有信号量的线程只能等待服务响应或从超时中返回，即可能出现长时间等待。线程池模式下，当超过指定时间未响应的服务，Hystrix会通过响应中断的方式通知线程立即结束并返回

  - ##### hystrix实现流程

    - 构建HystrixCommand或者HystrixObservableCommand对象，用于封装请求，并在构造方法配置请求被执行需要的参数。
    - 执行命令，Hystrix提供了4种执行命令的方法。
    - 检查是否有相同命令执行的缓存，若启用了缓存，且缓存可用，直接使用缓存响应请求。Hystrix支持请求缓存，但需要用户自定义启动。
    - 检查断路器是否打开，如果打开走 第8步。
    - 检查线程池或者信号量是否被消耗完，如果已满，走第8步。
    - 调用HystrixCommand的run 或者 HystrixObservableCommand的construct 执行被封装的调用逻辑，如果执行失败或超时，走第8步。
    - 计算链路的健康情况
    - 在命令执行失败时获取fallback逻辑。
    - 返回响应。

#### 网关

- 微服务没有网关，会有下面的问题：

  1. 客户端请求多个微服务，增加了客户端复杂性，每个微服务都要做用户认证，限流等，避免和多个微服务打交道的复杂性。
  2. 有跨域问题，不在同一个域。
  3. 认证复杂，每个服务都要独立认证，服务要求的权限不一致。
  4. 难以重构。因为微服务被客户端调用着，重构难以实施。
- Zuul是Netflix开源的微服务网关，核心是一系列过滤器。这些过滤器可以完成以下功能。

  1. 是所有微服务入口，进行分发。
  2. 身份认证与安全。识别合法的请求，拦截不合法的请求。
  3. 监控。在入口处监控，更全面。
  4. 动态路由。动态将请求分发到不同的后端集群。
  5. 压力测试。可以逐渐增加对后端服务的流量，进行测试。
  6. 负载均衡。也是用ribbon。
  7. 限流（望京超市）。比如我每秒只要1000次，10001次就不让访问了。
- Zuul的大部分功能都是有过滤器实现的。




### 分布式事务的解决方案

##### 柔韧事物

- 因为对于微服务的话来说，肯定会引起分布式事物的问题。目前的最理想的方案就是这个：保证最终的一致性

```java
刚性事务：遵循ACID原则，强一致性。
柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。
```



### ThreadLocal

- 当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。

- https://www.pianshen.com/article/2853116327/

- http://www.threadlocal.cn/#1

##### threadlocal使用

- 每次使用完ThreadLocal都调用它的remove()方法清除数据

- 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。
- 这里会涉及到java的引用类型和 java的对象的生命周期

##### java引用类型

​		每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。

`//创建一个引用，引用可以独立存在，并不一定需要与一个对象关联 String s;`

- 引用回收
  - 引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。
  - 可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

- 强引用

  - 使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
  - 如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。

- 软引用

  - 软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。

- 弱引用

  - VM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。

    ```java
    	private static void testWeakReference() {
    		for (int i = 0; i < 10; i++) {
    			byte[] buff = new byte[1024 * 1024];
    			WeakReference<byte[]> sr = new WeakReference<>(buff);
    			list.add(sr);
    		}
    		
    		System.gc(); //主动通知垃圾回收
    		
    		for(int i=0; i < list.size(); i++){
    			Object obj = ((WeakReference) list.get(i)).get();
    			System.out.println(obj);
    		}
    	}
    ```

- 虚引用

  - 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

- 引用队列

  - 引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

    与软引用、弱引用不同，虚引用必须和引用队列一起使用。

##### java类生命周期

​		java类的生命周期就是指一个class文件从加载到卸载的全过程。

​		https://blog.csdn.net/yanliguoyifang/article/details/80964237![类的生命周期](/类的生命周期.jpg)

​		 其中，验证——准备——解析 称为连接阶段，除了解析外，其他阶段是顺序发生的，而解析可以与这些阶段交叉进行，因为Java支持动态绑定（晚期绑定），需要运行时才能确定具体类型；在使用阶段实例化对象。

- 类的初始化触发
  - 类的加载机制没有明确的触发条件，但是有5种情况下必须对类进行初始化，那么 加载——验证——准备 就必须在此之前完成了。
    - 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。
    - 通过反射方式执行以上三种行为。
    - 初始化子类的时候，会触发父类的初始化。
    - 虚拟机启动时，初始化一个执行主类；（作为程序入口直接运行时（也就是直接调用main方法）。）
    - 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化
  - 注意，**有且只有五种情况必须对类进行初始化，这**五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”



